<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Zombie Transactions Analyzer</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js" integrity="sha512-4VafBf+GO6zkRgZNpmjDoE7YQDdyCjTiMQuuLHfoalGoVYLRNvKcJsteVEhDWUpAJZciV06P88GJEpXHIFaY5w==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.7.107/pdf.min.js" integrity="sha512-k6VKgf/mBlC9ZwTe74MkRUYw35vj0IadB1iKsFcfoTmyaKOA1NVuMcZV8K4D4ew3Efr2E1VlzDq+W8sELpAoKA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<style>
:root {
  --bg: #fff;
  --fg: #000;
  --pre-bg: #f4f4f4;
  color-scheme: light dark;
}
@media (prefers-color-scheme: dark) {
  :root {
    --bg: #121212;
    --fg: #eee;
    --pre-bg: #1e1e1e;
  }
}
body {
  font-family: Arial, sans-serif;
  margin: 0;
  min-height: 100vh;
  background: var(--bg);
  color: var(--fg);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  text-align: center;
  gap: 1em;
}
label {
  display: block;
  margin-top: 1em;
}
pre {
  background: var(--pre-bg);
  padding: 1em;
}
#log {
  max-height: 200px;
  overflow-y: auto;
  text-align: left;
}
button {
  padding: 0.5em 1.5em;
  font-size: 1em;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}
h1 {
  font-size: 2em;
  text-shadow: 0 0 5px #888;
}
</style>
</head>
<body>
<h1>Zombie Transactions Analyzer</h1>
<label>
  CSV/PDF Files:
  <input type="file" id="csvFile" accept=".csv,.pdf" multiple>
</label>
<button id="analyzeBtn">Analyze</button>
<pre id="output"></pre>
<pre id="log"></pre>
<script>
function log(msg) {
  const el = document.getElementById('log');
  el.textContent += msg + '\n';
  el.scrollTop = el.scrollHeight;
}
function getMonth(dateStr) {
  const d = new Date(dateStr);
  if (isNaN(d)) throw new Error('Unrecognized date format: ' + dateStr);
  const y = d.getFullYear();
  const m = String(d.getMonth() + 1).padStart(2, '0');
  return `${y}-${m}`;
}

function findRecurringTransactions(rows, monthsThreshold) {
  const seen = {};
  rows.forEach(row => {
    const desc = (row.Description || row.Payee || '').trim();
    const amount = parseFloat(row.Amount);
    const dateStr = row.Date || row['Transaction Date'] || '';
    if (!desc || isNaN(amount) || !dateStr) return;
    let month;
    try { month = getMonth(dateStr); } catch (e) { return; }
    const key = desc + '||' + amount;
    if (!seen[key]) seen[key] = new Set();
    seen[key].add(month);
  });
  const results = [];
  Object.keys(seen).forEach(key => {
    if (seen[key].size >= monthsThreshold) {
      const [desc, amount] = key.split('||');
      results.push({ description: desc, amount: parseFloat(amount) });
    }
  });
  return results;
}

function guessThreshold(rows) {
  const months = new Set();
  rows.forEach(r => {
    const dateStr = r.Date || r['Transaction Date'] || '';
    try { months.add(getMonth(dateStr)); } catch (e) { /* ignore */ }
  });
  return Math.max(2, Math.ceil(months.size / 2));
}

pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.7.107/pdf.worker.min.js';

function parsePdf(file) {
  log('Parsing PDF: ' + file.name);
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = async e => {
      try {
        const typed = new Uint8Array(e.target.result);
        const pdf = await pdfjsLib.getDocument({ data: typed }).promise;
        let text = '';
        for (let i = 1; i <= pdf.numPages; i++) {
          const page = await pdf.getPage(i);
          const content = await page.getTextContent();
          text += content.items.map(it => it.str).join(' ') + '\n';
        }
        log('Parsed ' + pdf.numPages + ' pages from ' + file.name);
        resolve(text);
      } catch (err) { log('Error parsing PDF: ' + err.message); reject(err); }
    };
    reader.onerror = reject;
    reader.readAsArrayBuffer(file);
  });
}

function parseFile(file) {
  log('Reading ' + file.name);
  if (file.name.toLowerCase().endsWith('.pdf')) {
    return parsePdf(file).then(text => {
      const rows = Papa.parse(text, {header: true, skipEmptyLines: true}).data;
      log('Parsed ' + rows.length + ' rows from ' + file.name);
      return rows;
    });
  }
  return new Promise((resolve, reject) => {
    Papa.parse(file, {
      header: true,
      skipEmptyLines: true,
      complete: results => { log('Parsed ' + results.data.length + ' rows from ' + file.name); resolve(results.data); },
      error: reject
    });
  });
}

async function analyze() {
  const fileInput = document.getElementById('csvFile');
  const output = document.getElementById('output');
  const files = Array.from(fileInput.files || []);
  if (files.length === 0) { output.textContent = 'Please select at least one CSV or PDF file.'; return; }
  document.getElementById('log').textContent = '';
  log('Analyzing ' + files.length + ' file(s)');
  try {
    const rowsArrays = await Promise.all(files.map(parseFile));
    const rows = rowsArrays.flat();
    const threshold = guessThreshold(rows);
    log('Using threshold of ' + threshold + ' month(s)');
    const recurring = findRecurringTransactions(rows, threshold);
    log('Found ' + recurring.length + ' recurring transaction(s)');
    if (recurring.length === 0) {
      output.textContent = 'No recurring transactions found.';
    } else {
      output.textContent = recurring.map(r => `${r.description}: $${r.amount.toFixed(2)}`).join('\n');
    }
  } catch (err) {
    output.textContent = 'Error processing files: ' + err.message;
    log('Error: ' + err.message);
  }
}

document.getElementById('analyzeBtn').addEventListener('click', analyze);
</script>
</body>
</html>
